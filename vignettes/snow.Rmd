---
title: "Spatial distribution of snow - exploratory tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spatial distribution of snow - exploratory tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Spatial distribution of snow

This tutorial explores whether 4Dmodeller can be used to model the spatial distribution of snow in the Bayelva area on Svalbard, based on once-a-year point-based manual snow depth measurements for several years and snow cover duration derived from time lapse camera imagery (Aalstad et al., 2020). This data has been used before for snow data assimilation (Aalstad et al., 2018) and permafrost modeling (Zweigel et al., 2021) using modeling and data assimilation methods (see references). Additionally, we included elevation and other derived topographic parameters (slope, aspect, topographic position index) as these are known to influence the snow depth distribution. These topographic parameters were derived from a high resolution digital elevation model (Boike et al., 2019). The dataset used in this tutorial has been prepared by Kristoffer Aalstad as a netCDF by combining and processing the following publicly available datasets that have been used in several studies (see literature references):

Westermann, S. (2020).Snow depth and ground surface temperature at Bayelva research site, Svalbard [Data set]. Norstore. https://doi.org/10.11582/2020.00024

Aalstad, K., and Westermann. S. (2021). ACS_Bayelva_class: 302 high-resolution snow cover maps covering the 2012-2017 snowmelt seasons in the Bayelva catchment (Svalbard, Norway) (2.0) [Data set]. Zenodo. https://doi.org/10.5281/zenodo.5010944

Boike, J., Juszak, I., Lange, S., Chadburn, S., Burke, E., Overduin, P. P., Roth, K., Ippisch, O., Bornemann, N., Stern, L., Gouttevin, I., Hauber, E., & Westermann, S. (2018). HRSC-AX data products (DEM and multi channel) from aerial overflights in 2008 over Bayelva (Brøggerhalvøya peninsula, Spitsbergen). (Version 1) [Data set]. Zenodo. https://doi.org/10.1594/PANGAEA.884730

The dataset is originally projected (UTM zone 33X) and available in the data sub-folder in this repository. As UTM was not supported for all steps we anticipated while developing this tutorial (see below), we also created also a lat/lon version of the same data.

### Literature references 

Aalstad, K., Westermann, S., Schuler, T. V., Boike, J., and Bertino, L. (2018). Ensemble-based assimilation of fractional snow-covered area satellite retrievals to estimate the snow distribution at Arctic sites. The Cryosphere, 12, 247–270, https://doi.org/10.5194/tc-12-247-2018  

Boike, J., Nitzbon, J., Anders, K., Grigoriev, M., Bolshiyanov, D., Langer, M., Lange, S., Bornemann, N., Morgenstern, A., Schreiber, P., Wille, C., Chadburn, S., Gouttevin, I., Burke, E., and Kutzbach, L.: A 16-year record (2002–2017) of permafrost, active-layer, and meteorological conditions at the Samoylov Island Arctic permafrost research site, Lena River delta, northern Siberia: an opportunity to validate remote-sensing data and land surface, snow, and permafrost models, Earth Syst. Sci. Data, 11, 261–299, https://doi.org/10.5194/essd-11-261-2019, 2019. 

Aalstad, K., Westermann, S., and Bertino, L. (2020). Evaluating satellite retrieved fractional snow-covered area at a high-Arctic site using terrestrial photography. Remote Sensing of Environment, 239, https://doi.org/10.1016/j.rse.2019.111618 

Zweigel, R. B., Westermann, S., Nitzbon, J., Langer, M., Boike, J., Etzelmüller, B., and Vikhamar Schuler, T. (2021). Simulating snow redistribution and its effect on ground surface temperature at a high-Arctic site on Svalbard. Journal of Geophysical Research: Earth Surface, 126, e2020JF005673. https://doi.org/10.1029/2020JF005673 

## Import and load the data

```{r modules}
# load modules used in this tutorial
library(ncdf4)
#library(tidyverse)
```

```{r dataload}
# Find where your data is stored locally
ncpath <- dirname(rstudioapi::getSourceEditorContext()$path)
ncname <- "Bayelva_snow" 
ncfname <- paste(ncpath,'/data/', ncname, ".nc", sep="")

#open data 
ncin <- nc_open(ncfname) 
#head(ncin)
```

## Get relevant features

The netcdf file has both point measurements of snow depth (ds, or translated into SWE: Ds) for several years, and continuous raster data with snow depth duration for several years and topographic features. We start with the snow depth points only:

```{r dataselect}
# specify the longitude and latitude columns. Note that the coordinates are utm!
longitude <- ncvar_get(ncin,"xs") 
latitude <-ncvar_get(ncin,"ys")

# Get the first year of snow depth (ds)
ds <- ncvar_get(ncin,"ds")[,1]

# Create a data frame
df <- data.frame(LONG = longitude,LAT = latitude,ds) 
head(df)
```

## Build the mesh

When trying this whit our UTM projected dataset, we don't get a result:

```{r, eval = FALSE}
fdmr::mesh_builder(spatial_data = df)
```

The shiny app seems not to work with UTM, so we when working with UTM we need to try and do this non-interactively.

```{r plotmesh}
# Define a proj string for our UTM zone
crs <- "+proj=utm +zone=33" 

# use fmesher directly rather than the fdmr wrapper:
mesh <- fmesher::fm_mesh_2d_inla(loc = df[,c(1,2)], 
                                 max.edge = c(20,40),
                                 crs = crs ) 

# plot the result
plot(mesh)
```

We would like to also show our data points and see this in a geographical context to check whether everything is looking OK. This is causing problems - fdmr seems not to be able to deal with our UTM coordinates.

```{r, eval = FALSE}

fdmr::plot_mesh(mesh=mesh, spatial_data = df[,c(1,2)])
```

The plot_mesh function seems to assume lat/lon coordinates and thus zooms out to max.

## Redo this with geographical coordinates

Let's see whether this works if our data is in geographical coordinates instead. Redo all the steps from above:

```{r latlonload}
ncname_ll <- "Bayelva_snow_geo"
ncfname_ll <- paste(ncpath, '/data/', ncname_ll, ".nc", sep="")
# Open data
ncin_ll <- nc_open(ncfname_ll)

# Create a data frame with the  first year of snow depth (ds)
df_ll <- data.frame(LONG = ncvar_get(ncin_ll,"lons"),
                 LAT = ncvar_get(ncin_ll,"lats"),
                 DS = ncvar_get(ncin_ll,"ds")[,1])

## Store the point locations in a separate data frame:
location_data_ll = df_ll[,c(1,2)]
```

```{r, eval = FALSE}
# Try with the interactive mesh_builder
fdmr::mesh_builder(location_data_ll)
```

The mesh_builder loads the shiny widget and creates a mesh, however there are several issues: 

- the map part of the window covers the entire window, so the rulers disappear 

- the mesh is far too coarse for the small area we are looking at (1km2) 

- closing the widget window doesn't stop the underlying processes to run, consequently RStudio is blocked and needs to be restarted, as ctrl + c or interrupting by clicking the STOP button don't have any effect.

Let's try to specify the mesh manually using values for max.edge and cutoff that are reasonable for our domain and length scales.

```{r latlonmesh_manually}
# look at the range of the data to derive the mesh parameters
initial_range <- diff(range(location_data_ll[, "LONG"])) / 5
max_edge <- initial_range / 8
offset <- initial_range/2

# make the mesh from the locations
mesh <- fmesher::fm_mesh_2d(loc = location_data_ll[, c("LONG", "LAT")],
                                 max.edge = c(1, 2) * max_edge,
                                 offset = c(1,1.5)*offset,
                                 cutoff = max_edge/10
                                 )
fdmr::plot_mesh(mesh,spatial_data = location_data_ll) 
```

This mesh is already a better starting point. There are two things we are not happy about: 

- The mesh is obviously distorted in N/S direction: With latitude/longitude units representing substantially different spatial distances at polar latitudes, edge lengths should be defined differently in E/W and N/S. Or one could simply use UTM (which is currently not supported for the visualisation tools). 

- Is the mesh dense enough to represent snow depth variability between the measurement points, and is the mesh in physically useful locations? Terrain and derivatives are strong drivers of spatial snow depth distribution, and they should thus ideally be considered for the mesh generation.

## Design the prior and the model

We create a prior with the Matérn function, a penalized complexity prior defined by range and standard deviation [cite Finn].
The range parameter defines the lenght of the influence of each observation.

In this small experiment, we have experimented by creating two different priors with two different range.
The model is a stochastic partial differential equation (SPDE).

```{prior creation}
#julia add code for creating the two models
```

## Fitting the model



## Spatial covariance, and how we could use that

A future development we would like to work on, is to design the prior to be anisotropic. What we mean, is that the correlations should be allowed to behave differently in each dimension of the feature space where we define distances between points.


# TO DO part

## Get the rasters in and use that information to build the mesh

## Get model results considering some or all data and predictors

## How to deal with real zeros? (Zero snow depth)


```{r}
library(ncdf4)
library(ggplot2)

# Import the data
ncpath <- "~/"
ncname <- "Bayelva_snow_geo"  
ncfname <- paste(ncpath, ncname, ".nc", sep="")

# Open data 
ncin <- nc_open(ncfname)




# Create a data frame with the  first year of snow depth (ds)
df <- data.frame(LONG = ncvar_get(ncin,"lons"),
                 LAT = ncvar_get(ncin,"lats"),
                 #elev = ncvar_get(ncin,"zs"),
                 DS = ncvar_get(ncin,"ds")[,1],
                 DS_log = log(ncvar_get(ncin,"ds")[,1]))

## Ready for modelling!


# look at the range of the data
initial_range <- diff(range(df[, "LONG"])) / 5
max_edge <- initial_range / 4
offset <- initial_range/2

mesh <- fmesher::fm_mesh_2d(
  loc = location_data[, c("LONG", "LAT")],
  max.edge = c(1, 2) * max_edge,
  offset = c(1,1.5)*offset,
  cutoff = max_edge/10 
)

fdmr::plot_mesh(mesh,spatial_data = location_data)

## Start defining the priors
# the prior range is the distance that the process should stop effecting, so in this case it is currently 20km away from the node center

spde1 <- INLA::inla.spde2.pcmatern(
  mesh = mesh,
  prior.range = c(initial_range, 0.5),
  prior.sigma = c(1, 0.01)
)

spde2 <- INLA::inla.spde2.pcmatern(
  mesh = mesh,
  prior.range = c(initial_range*5, 0.5),
  prior.sigma = c(1, 0.01)
)

## Creating our data frame into a SpatialPointsDataFrame ()

sp::coordinates(df) <- c("LONG", "LAT")

formula1 <- DS ~ 0 + Intercept(1)+
  f(
    main = df,
    model = spde1
  )


formula2 <- DS ~ 0 + Intercept(1)   +
  f(
    main = df,
    model = spde2
  )


inlabru_model1 <- inlabru::bru(formula1,
                               data = df,
                               family = "gaussian",
                               options = list(
                                 verbose = FALSE
                               )
)

inlabru_model2 <- inlabru::bru(formula2,
                               data = df,
                               family = "gaussian",
                               options = list(
                                 verbose = FALSE
                               )
)

summary(inlabru_model1)
summary(inlabru_model2)


plot(exp(inlabru_model1$summary.fitted.values$mean[1:nrow(df@data)]),exp(df@data$DS))
plot(exp(inlabru_model2$summary.fitted.values$mean[1:nrow(df@data)]),exp(df@data$DS))


plot(exp(inlabru_model1$summary.fitted.values$mean[1:nrow(df@data)]),exp(df@data$DS))
plot(exp(inlabru_model2$summary.fitted.values$mean[1:nrow(df@data)]),exp(df@data$DS))


fdmr::model_viewer(
  model_output = inlabru_model1,
  mesh = mesh,
  measurement_data = df,
  data_distribution = "Gaussian"
)

fdmr::model_viewer(
  model_output = inlabru_model2,
  mesh = mesh,
  measurement_data = df,
  data_distribution = "Gaussian"
)


```

