---
title: "Spatial distribution of snow - exploratory tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spatial distribution of snow - exploratory tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Spatial distribution of snow

This tutorial explores whether 4Dmodeller can be used to model the spatial distribution of snow in the Bayelva area on Svalbard, based on once-a-year point-based manual snow depth measurements for several years and snow cover duration derived from time lapse camera imagery. This data has been used before to estimate snow depth and permafrost using data assimilation methods (see literature references). Additionally, we included topography and topographic parameters as these are known to correlate with snow depth distribution. The dataset used in this tutorial has been prepared by Kristoffer Aalstad based on the following publicly available data:

**XXX ADD dois for the datasets**

The dataset is originally projected (UTM zone 33X) and available in the data sub-folder in this repository. As UTM was not supported for all steps we anticipated while developing this tutorial (see below), we also created also a lat/lon version of the same data.

### Literature references

Aalstad, K. et al. (2018). <doi:10.5194/tc-12-247-2018>. TC.

Aalstad, K. et al. (2020). doi: 10.1016/j.rse.2019.111618. RSE.

Boike, J. et al. (2018). <doi:10.5194/essd-10-355-2018>. ESSD.

Zweigel, R. et al. (2021). <doi:10.1029/2020JF005673>.

## Import and load the data

```{r modules}
# load modules used in this tutorial
library(ncdf4)
#library(tidyverse)
```

```{r dataload}
# Find where your data is stored locally
ncpath <- dirname(rstudioapi::getSourceEditorContext()$path)
ncname <- "Bayelva_snow" 
ncfname <- paste(ncpath,'/data/', ncname, ".nc", sep="")

#open data 
ncin <- nc_open(ncfname) 
#head(ncin)
```

## Get relevant features

The netcdf file has both point measurements of snow depth (ds, or translated into SWE: Ds) for several years, and continuous raster data with snow depth duration for several years and topographic features. We start with the snow depth points only:

```{r dataselect}
# specify the longitude and latitude columns. Note that the coordinates are utm!
longitude <- ncvar_get(ncin,"xs") 
latitude <-ncvar_get(ncin,"ys")

# Get the first year of snow depth (ds)
ds <- ncvar_get(ncin,"ds")[,1]

# Create a data frame
df <- data.frame(LONG = longitude,LAT = latitude,ds) 
head(df)
```

## Build the mesh

When trying this whit our UTM projected dataset, we don't get a result:

```{r, eval = FALSE}
fdmr::mesh_builder(spatial_data = df)
```

The shiny app seems not to work with UTM, so we when working with UTM we need to try and do this non-interactively.

```{r plotmesh}
# Define a proj string for our UTM zone
crs <- "+proj=utm +zone=33" 

# use fmesher directly rather than the fdmr wrapper:
mesh <- fmesher::fm_mesh_2d_inla(loc = df[,c(1,2)], 
                                 max.edge = c(20,40),
                                 crs = crs ) 

# plot the result
plot(mesh)
```

We would like to also show our data points and see this in a geographical context to check whether everything is looking OK. This is causing problems - fdmr seems not to be able to deal with our UTM coordinates.

```{r, eval = FALSE}

fdmr::plot_mesh(mesh=mesh, spatial_data = df[,c(1,2)])
```

The plot_mesh function seems to assume lat/lon coordinates and thus zooms out to max.

## Redo this with geographical coordinates

Let's see whether this works if our data is in geographical coordinates instead. Redo all the steps from above:

```{r latlonload}
ncname_ll <- "Bayelva_snow_geo"
ncfname_ll <- paste(ncpath, '/data/', ncname_ll, ".nc", sep="")
# Open data
ncin_ll <- nc_open(ncfname_ll)

# Create a data frame with the  first year of snow depth (ds)
df_ll <- data.frame(LONG = ncvar_get(ncin_ll,"lons"),
                 LAT = ncvar_get(ncin_ll,"lats"),
                 DS = ncvar_get(ncin_ll,"ds")[,1])

## Store the point locations in a separate data frame:
location_data_ll = df_ll[,c(1,2)]
```

```{r, eval = FALSE}
# Try with the interactive mesh_builder
fdmr::mesh_builder(location_data_ll)
```

The mesh_builder loads the shiny widget and creates a mesh, however there are several issues: 

- the map part of the window covers the entire window, so the rulers disappear 

- the mesh is far too coarse for the small area we are looking at (1km2) 

- closing the widget window doesn't stop the underlying processes to run, consequently RStudio is blocked and needs to be restarted, as ctrl + c or interrupting by clicking the STOP button don't have any effect.

Let's try to specify the mesh manually using values for max.edge and cutoff that are reasonable for our domain and length scales.

```{r latlonmesh_manually}
# look at the range of the data to derive the mesh parameters
initial_range <- diff(range(location_data_ll[, "LONG"])) / 5
max_edge <- initial_range / 8
offset <- initial_range/2

# make the mesh from the locations
mesh <- fmesher::fm_mesh_2d(loc = location_data_ll[, c("LONG", "LAT")],
                                 max.edge = c(1, 2) * max_edge,
                                 offset = c(1,1.5)*offset,
                                 cutoff = max_edge/10
                                 )
fdmr::plot_mesh(mesh,spatial_data = location_data_ll) 
```

This mesh is already a better starting point. There are two things we are not happy about: 

- The mesh is obviously distorted in N/S direction: With latitude/longitude units representing substantially different spatial distances at polar latitudes, edge lengths should be defined differently in E/W and N/S. Or one could simply use UTM (which is currently not supported for the visualisation tools). 

- Is the mesh dense enough to represent snow depth variability between the measurement points, and is the mesh in physically useful locations? Terrain and derivatives are strong drivers of spatial snow depth distribution, and they should thus ideally be considered for the mesh generation.


# TO DO part

## Get the rasters in and use that information to build the mesh

## Spatial covariance, and how we could use that

## Get model results considering some or all data and predictors

## How to deal with real zeros? (Zero snow depth)
